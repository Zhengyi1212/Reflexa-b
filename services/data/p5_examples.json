[
  {
    "id": "p5_adv_001",
    "tag": "炫彩彗星拖尾",
    "image": "/image/1.png",
    "code": "let particles = [];\nlet hue = 0;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  colorMode(HSB, 360, 100, 100, 100);\n  noStroke();\n}\n\nfunction draw() {\n  background(0, 0, 10, 25);\n  hue += 0.5;\n  if (hue > 360) hue = 0;\n\n  if (mouseIsPressed || touches.length > 0) {\n    for (let i = 0; i < 2; i++) {\n      particles.push(new Particle(mouseX, mouseY, hue));\n    }\n  }\n\n  for (let i = particles.length - 1; i >= 0; i--) {\n    particles[i].update();\n    particles[i].show();\n    if (particles[i].isFinished()) {\n      particles.splice(i, 1);\n    }\n  }\n}\n\nclass Particle {\n  constructor(x, y, h) {\n    this.pos = createVector(x, y);\n    this.vel = p5.Vector.random2D().mult(random(1, 4));\n    this.acc = createVector(0, 0.05);\n    this.lifespan = 100;\n    this.baseHue = h;\n  }\n\n  isFinished() {\n    return this.lifespan < 0;\n  }\n\n  update() {\n    this.vel.add(this.acc);\n    this.pos.add(this.vel);\n    this.lifespan -= 2;\n  }\n\n  show() {\n    let currentHue = (this.baseHue + (100 - this.lifespan) * 0.5) % 360;\n    let saturation = this.lifespan;\n    let brightness = 100;\n    fill(currentHue, saturation, brightness, this.lifespan);\n    let d = map(this.lifespan, 0, 100, 0, 20);\n    ellipse(this.pos.x, this.pos.y, d, d);\n  }\n}"
  },
  {
    "id": "p5_adv_002",
    "tag": "有机水母群",
    "image": "/image/2.png",
    "code": "let jellies = [];\n\nfunction setup() {\n  createCanvas(800, 1200);\n  for (let i = 0; i < 10; i++) {\n    jellies.push(new Jelly(random(width), random(height)));\n  }\n}\n\nfunction draw() {\n  background(0, 25, 50);\n  for (let jelly of jellies) {\n    jelly.update();\n    jelly.display();\n  }\n}\n\nfunction mousePressed() {\n  jellies.push(new Jelly(mouseX, mouseY));\n}\n\nclass Jelly {\n  constructor(x, y) {\n    this.pos = createVector(x, y);\n    this.vel = createVector(0, -1);\n    this.noiseOffsetX = random(1000);\n    this.bodySize = random(20, 50);\n    this.hue = random(180, 240);\n    this.tentacles = [];\n    for (let i = 0; i < 8; i++) {\n      this.tentacles.push(new Tentacle(this.pos, this.bodySize));\n    }\n  }\n\n  update() {\n    let dirX = map(noise(this.noiseOffsetX), 0, 1, -0.5, 0.5);\n    this.vel.x = dirX;\n    this.pos.add(this.vel);\n    this.noiseOffsetX += 0.01;\n\n    if (this.pos.y < -this.bodySize) this.pos.y = height + this.bodySize;\n    \n    for (let t of this.tentacles) {\n      t.update(this.pos);\n    }\n  }\n\n  display() {\n    noStroke();\n    fill(this.hue, 50, 100, 40);\n    ellipse(this.pos.x, this.pos.y, this.bodySize, this.bodySize * 1.2);\n    for (let t of this.tentacles) {\n      t.display(this.hue);\n    }\n  }\n}\n\nclass Tentacle {\n  constructor(parentPos, parentSize) {\n    this.segments = [];\n    this.numSegments = 15;\n    for (let i = 0; i < this.numSegments; i++) {\n      this.segments.push(parentPos.copy());\n    }\n    this.len = parentSize / this.numSegments;\n  }\n\n  update(parentPos) {\n    this.segments[0] = parentPos.copy();\n    for (let i = 1; i < this.numSegments; i++) {\n      let prev = this.segments[i - 1];\n      let current = this.segments[i];\n      let angle = atan2(current.y - prev.y, current.x - prev.x);\n      current.x = prev.x + cos(angle) * this.len;\n      current.y = prev.y + sin(angle) * this.len + 0.5;\n    }\n  }\n\n  display(hue) {\n    stroke(hue, 60, 100, 60);\n    strokeWeight(2);\n    noFill();\n    beginShape();\n    for (let seg of this.segments) {\n      vertex(seg.x, seg.y);\n    }\n    endShape();\n  }\n}"
  },
  {
    "id": "p5_adv_003",
    "tag": "双极引力场",
    "image": "/image/3.png",
    "code": "let particles = [];\nconst numParticles = 300;\nlet attractor1, attractor2;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  for (let i = 0; i < numParticles; i++) {\n    particles.push(new Particle(random(width), random(height)));\n  }\n  colorMode(HSB);\n}\n\nfunction draw() {\n  background(0, 0, 0, 0.1);\n  attractor1 = createVector(width / 4, height / 2);\n  attractor2 = createVector(mouseX, mouseY);\n  \n  strokeWeight(2);\n  for (let p of particles) {\n    p.attracted(attractor1, 1);\n    p.attracted(attractor2, -1.2);\n    p.update();\n    p.show();\n  }\n}\n\nclass Particle {\n  constructor(x, y) {\n    this.pos = createVector(x, y);\n    this.vel = createVector();\n    this.acc = createVector();\n    this.maxSpeed = 5;\n  }\n\n  attracted(target, polarity) {\n    let force = p5.Vector.sub(target, this.pos);\n    let d = force.mag();\n    d = constrain(d, 5, 100);\n    let strength = (polarity * 15) / (d * d);\n    force.setMag(strength);\n    this.acc.add(force);\n  }\n\n  update() {\n    this.vel.add(this.acc);\n    this.vel.limit(this.maxSpeed);\n    this.pos.add(this.vel);\n    this.acc.mult(0);\n  }\n\n  show() {\n    let angle = this.vel.heading();\n    let hue = map(angle, -PI, PI, 0, 360);\n    stroke(hue, 80, 100, 0.6);\n    point(this.pos.x, this.pos.y);\n  }\n}"
  },
  {
    "id": "p5_adv_004",
    "tag": "柏林噪声流场",
    "image": "/image/4.png",
    "code": "let particles = [];\nlet noiseScale = 0.01;\nlet numParticles = 500;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  for(let i = 0; i < numParticles; i++) {\n    particles[i] = new Particle();\n  }\n  background(0);\n  colorMode(HSB);\n}\n\nfunction draw() {\n  let noiseOffsetX = mouseX * 0.001;\n  let noiseOffsetY = mouseY * 0.001;\n\n  for(let p of particles) {\n    p.update(noiseOffsetX, noiseOffsetY);\n    p.show();\n    p.edges();\n  }\n}\n\nclass Particle {\n  constructor() {\n    this.pos = createVector(random(width), random(height));\n    this.vel = createVector(0, 0);\n    this.acc = createVector(0, 0);\n    this.maxSpeed = 2;\n  }\n\n  update(offsetX, offsetY) {\n    let angle = noise(this.pos.x * noiseScale + offsetX, this.pos.y * noiseScale + offsetY) * TWO_PI * 4;\n    let force = p5.Vector.fromAngle(angle);\n    force.setMag(0.1);\n    this.acc.add(force);\n    \n    this.vel.add(this.acc);\n    this.vel.limit(this.maxSpeed);\n    this.pos.add(this.vel);\n    this.acc.mult(0);\n  }\n\n  show() {\n    let hue = map(this.pos.x, 0, width, 180, 300);\n    stroke(hue, 100, 100, 0.05);\n    strokeWeight(1.5);\n    point(this.pos.x, this.pos.y);\n  }\n\n  edges() {\n    if (this.pos.x > width) this.pos.x = 0;\n    if (this.pos.x < 0) this.pos.x = width;\n    if (this.pos.y > height) this.pos.y = 0;\n    if (this.pos.y < 0) this.pos.y = height;\n  }\n}"
  },
  {
    "id": "p5_adv_005",
    "tag": "递归树",
    "image": "/image/5.png",
    "code": "var angle = 0;\nvar len = 120;\n\nfunction setup() {\n  createCanvas(800, 1200);\n}\n\nfunction draw() {\n  background(10, 20, 30);\n  angle = map(mouseX, 0, width, 0, PI / 2);\n  len = map(mouseY, 0, height, 50, 200);\n  \n  translate(width / 2, height * 0.5); \n  stroke(255);\n  branch(len);\n}\n\nfunction branch(len) {\n  strokeWeight(max(1, len / 10));\n  line(0, 0, 0, -len);\n  translate(0, -len);\n\n  if (len > 4) {\n    push();\n    rotate(angle);\n    branch(len * 0.67);\n    pop();\n\n    push();\n    rotate(-angle);\n    branch(len * 0.67);\n    pop();\n  }\n}"
  },
  {
    "id": "p5_adv_006",
    "tag": "万花尺画板",
    "image": "/image/6.png",
    "code": "var angle = 0;\nvar r = 200;\nvar hue = 0;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  background(0);\n  colorMode(HSB);\n  strokeWeight(2);\n}\n\nfunction draw() {\n  let speed = map(mouseX, 0, width, 0.01, 0.2);\n  let ratio = map(mouseY, 0, height, 0.1, 2);\n  \n  let x = r * cos(angle) + (r * ratio) * cos(angle * 5);\n  let y = r * sin(angle) + (r * ratio) * sin(angle * 5);\n  \n  translate(width / 2, height / 2);\n  stroke(hue, 100, 100, 0.8);\n  point(x, y);\n  \n  angle += speed;\n  hue += 0.5;\n  if (hue > 360) hue = 0;\n}\n\nfunction mousePressed() {\n  background(0);\n}"
  },
  
  {
    "id": "p5_adv_007",
    "tag": "基础平移",
    "image": "/image/7.png",
    "code": "let x = 0;\nlet speed = 2;\n\nfunction setup() {\n  createCanvas(800, 1200);\n}\n\nfunction draw() {\n  background(20, 40, 80);\n  noStroke();\n  fill(255, 204, 0);\n  ellipse(x, height / 2, 50, 50);\n\n  x += speed;\n\n  if (x > width || x < 0) {\n    speed *= -1;\n  }\n}"
  },
  {
    "id": "p5_adv_008",
    "tag": "持续旋转",
    "image": "/image/8.png",
    "code": "let angle = 0;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  rectMode(CENTER);\n}\n\nfunction draw() {\n  background(240, 240, 240);\n  translate(width / 2, height / 2);\n  \n  // 鼠标控制旋转速度\n  let speed = map(mouseX, 0, width, 0.01, 0.2);\n  angle += speed;\n  \n  rotate(angle);\n  \n  stroke(50);\n  strokeWeight(4);\n  fill(100, 150, 250);\n  rect(0, 0, 150, 150);\n}"
  },
  {
    "id": "p5_adv_009",
    "tag": "HSB色彩循环",
    "image": "/image/9.png",
    "code": "let hueValue = 0;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  colorMode(HSB, 360, 100, 100);\n}\n\nfunction draw() {\n  // 色相值随时间变化\n  hueValue += 1;\n  if (hueValue > 360) {\n    hueValue = 0;\n  }\n  \n  background(hueValue, 80, 90);\n  \n  // 绘制一个颜色相反的圆\n  let oppositeHue = (hueValue + 180) % 360;\n  noStroke();\n  fill(oppositeHue, 80, 90);\n  ellipse(width / 2, height / 2, 200, 200);\n}"
  },
  {
    "id": "p5_adv_010",
    "tag": "飘落的雪花",
    "image": "/image/10.png",
    "code": "let snowflakes = [];\n\nfunction setup() {\n  createCanvas(800, 1200);\n  fill(255);\n  noStroke();\n}\n\nfunction draw() {\n  background(0, 0, 20);\n  let t = frameCount / 60;\n\n  // 每帧创建新的雪花\n  for (let i = 0; i < random(5); i++) {\n    snowflakes.push(new snowflake());\n  }\n\n  // 循环雪花\n  for (let flake of snowflakes) {\n    flake.update(t);\n    flake.display();\n  }\n}\n\nclass snowflake {\n  constructor(){\n    this.posX = 0;\n    this.posY = random(-50, 0);\n    this.initialangle = random(0, 2 * PI);\n    this.size = random(2, 5);\n    this.radius = sqrt(random(pow(width / 2, 2)));\n  }\n\n  update(time) {\n    let w = 0.6; // 角速度\n    let angle = w * time + this.initialangle;\n    this.posX = width / 2 + this.radius * sin(angle);\n    this.posY += pow(this.size, 0.5);\n\n    if (this.posY > height) {\n      let index = snowflakes.indexOf(this);\n      snowflakes.splice(index, 1);\n    }\n  }\n\n  display() {\n    ellipse(this.posX, this.posY, this.size);\n  }\n}"
  },
  {
    "id": "p5_adv_011",
    "tag": "弹力小球",
    "image": "/image/11.png",
    "code": "let ball;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  ball = new Ball(width / 2, 50);\n}\n\nfunction draw() {\n  background(220);\n  ball.update();\n  ball.display();\n}\n\nclass Ball {\n  constructor(x, y) {\n    this.position = createVector(x, y);\n    this.velocity = createVector(0, 0);\n    this.acceleration = createVector(0, 0.2); // 重力\n    this.radius = 25;\n    this.restitution = 0.85; // 弹性系数\n  }\n\n  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n\n    if (this.position.y > height - this.radius) {\n      this.position.y = height - this.radius;\n      this.velocity.y *= -this.restitution;\n    }\n  }\n\n  display() {\n    fill(50, 100, 200);\n    noStroke();\n    ellipse(this.position.x, this.position.y, this.radius * 2);\n  }\n}"
  },
  
  {
    "id": "p5_adv_014",
    "tag": "3D光影立方",
    "image": "/image/14.png",
    "code": "function setup() {\n  createCanvas(800, 1200, WEBGL);\n}\n\nfunction draw() {\n  background(10, 10, 20);\n  \n  // 环境光\n  ambientLight(60, 60, 60);\n  // 定向光\n  let dirX = (mouseX / width - 0.5) * 2;\n  let dirY = (mouseY / height - 0.5) * 2;\n  directionalLight(250, 250, 250, -dirX, -dirY, -1);\n  \n  noStroke();\n  specularMaterial(250);\n  shininess(50);\n  \n  translate(0, 0, 0);\n  rotateX(frameCount * 0.01);\n  rotateY(frameCount * 0.01);\n  \n  box(150);\n}"
  },
  {
    "id": "p5_adv_015",
    "tag": "矩阵代码雨",
    "image": "/image/15.png",
    "code": "const sketch = (p) => {\n  let streams = [];\n  let symbolSize = 20;\n\n  p.setup = () => {\n    p.createCanvas(800, 1200);\n    let x = 0;\n    for (let i = 0; i <= p.width / symbolSize; i++) {\n      let stream = new Stream();\n      stream.generateSymbols(x, p.random(-1000, 0));\n      streams.push(stream);\n      x += symbolSize;\n    }\n    p.textSize(symbolSize);\n    p.textFont('monospace');\n  };\n\n  p.draw = () => {\n    p.background(0, 150);\n    streams.forEach(stream => {\n      stream.render();\n    });\n  };\n\n  class Symbol {\n    constructor(x, y, speed, first) {\n      this.x = x;\n      this.y = y;\n      this.speed = speed;\n      this.first = first;\n      this.switchInterval = p.round(p.random(2, 25));\n      // 直接在构造函数中无条件地为符号赋一个初始值。\n      this.value = String.fromCharCode(0x30A0 + p.round(p.random(0, 96)));\n    }\n\n    // 这个方法现在只用于在动画循环中“更新”字符\n    setToRandomSymbol() {\n      if (p.frameCount % this.switchInterval == 0) {\n        this.value = String.fromCharCode(0x30A0 + p.round(p.random(0, 96)));\n      }\n    }\n  }\n\n  class Stream {\n    constructor() {\n      this.symbols = [];\n      this.totalSymbols = p.round(p.random(5, 35));\n      this.speed = p.random(5, 20);\n      this.x = 0;\n    }\n\n    generateSymbols(x, y) {\n      this.x = x;\n      this.symbols = [];\n      let first = p.round(p.random(0, 4)) == 1;\n      for (let i = 0; i <= this.totalSymbols; i++) {\n        let symbol = new Symbol(this.x, y, this.speed, first);\n        this.symbols.push(symbol);\n        y -= symbolSize;\n        first = false;\n      }\n    }\n\n    render() {\n      this.symbols.forEach(symbol => {\n        if (symbol.first) {\n          p.fill(180, 255, 180);\n        } else {\n          p.fill(0, 255, 70);\n        }\n        p.text(symbol.value, symbol.x, symbol.y);\n        symbol.y += symbol.speed;\n        symbol.setToRandomSymbol(); // 调用更新\n      });\n\n      let lastSymbol = this.symbols[this.symbols.length - 1];\n      if (lastSymbol.y > p.height) {\n        this.generateSymbols(this.x, p.random(-500, 0));\n      }\n    }\n  }\n};\n\n// --- 沙盒环境兼容性修复 ---\n// 每次运行时，都先移除旧的p5画布容器（如果存在），再创建一个新的。\n// 这是在iframe沙盒中确保环境干净、避免变量重定义错误的最佳方法。\nconst containerId = 'p5-matrix-container';\nlet oldContainer = document.getElementById(containerId);\nif (oldContainer) {\n  oldContainer.remove();\n}\nlet p5Container = document.createElement('div');\np5Container.id = containerId;\ndocument.body.appendChild(p5Container);\n\n// 将 p5 实例明确附加到我们创建的容器中\nnew p5(sketch, containerId);"
  },
  {
    "id": "p5_adv_016",
    "tag": "随机行走者",
    "image": "/image/16.png",
    "code": "class Walker {\n  constructor(){\n    this.x = width / 2;\n    this.y = height / 2;\n  }\n\n  render() {\n    stroke(255, 100);\n    strokeWeight(2);\n    point(this.x, this.y);\n  }\n\n  step() {\n    let choice = floor(random(4));\n    if (choice === 0) {\n      this.x++;\n    } else if (choice === 1) {\n      this.x--;\n    } else if (choice === 2) {\n      this.y++;\n    } else {\n      this.y--;\n    }\n    this.x = constrain(this.x, 0, width - 1);\n    this.y = constrain(this.y, 0, height - 1);\n  }\n}\n\nlet w;\n\nfunction setup() {\n  createCanvas(800, 1200);\n  w = new Walker();\n  background(0);\n}\n\nfunction draw() {\n  w.step();\n  w.render();\n}"
  },
  {
    "id": "p5_adv_017",
    "tag": "画线",
    "image": "/image/17.png",
     "code": "function setup() {\n  // 创建画布\n  createCanvas(710, 400);\n\n  // 设置背景为黑色\n  background(0);\n\n  // 设置线条宽度\n  strokeWeight(10);\n\n  // 设置颜色模式为色相-饱和度-亮度（HSB）\n  colorMode(HSB);\n\n  // 设置屏幕阅读器描述\n  describe('用户通过拖动鼠标在空白画布上绘制');\n}\n\nfunction mouseDragged() {\n  // 根据鼠标位置设置颜色，并绘制一条线\n  // 从上一个位置到当前的位置\n  let lineHue = mouseX - mouseY;\n  stroke(lineHue, 90, 90);\n  line(pmouseX, pmouseY, mouseX, mouseY);\n}"
},
  {
    "id": "p5_adv_018",
    "tag": "贝塞尔曲线",
    "image": "/image/18.png",
    "code": "// 定义 strokeHue 作为全局变量。此变量\n// 用于为每条线着色。\nlet strokeHue = 20;\n\nfunction setup() {\n  createCanvas(720, 400);\n\n  // 移除贝塞尔曲线的填充色并设置新的\n  // 线条粗细。将颜色模式更改为 HSB。\n  noFill();\n  strokeWeight(2);\n  colorMode(HSB);\n}\n\nfunction draw() {\n  describe(\n    '十条彩虹色的贝塞尔曲线。曲线的上锚点随着鼠标在黑色画布上悬停时移动。'\n  );\n\n  background(5);\n\n  // 创建 10 条贝塞尔曲线，锚点随\n  // 鼠标的 X 坐标变化。\n  for (let i = 0; i < 200; i += 20) {\n    // 在每次迭代时给线条的色相值加 10。\n    strokeColor = i + 10;\n\n    stroke(strokeColor, 50, 60);\n\n    bezier(mouseX - i / 2, 0 + i, 410, 20, 440, 300, 240 - i / 16, 300 + i / 8);\n  }\n}"
},
  {
    "id": "p5_adv_019",
    "tag": "连接的粒子",
    "image": "/image/19.png",
    
  "code": "// 存储路径对象的数组，每个路径包含一个粒子数组\nlet paths = [];\n\n// 下一颗粒子出现前的时间间隔\nlet framesBetweenParticles = 5;\nlet nextParticleFrame = 0;\n\n// 上一颗粒子的位置\nlet previousParticlePosition;\n\n// 粒子消失的时间\nlet particleFadeFrames = 300;\n\nfunction setup() {\n  createCanvas(720, 400);\n  colorMode(HSB);\n\n  // 从默认向量开始，然后用它来保存\n  // 上一颗粒子的位置\n  previousParticlePosition = createVector();\n  describe(\n    '当光标在黑色背景上拖动时，它会绘制一系列多彩的圆圈，这些圆圈被白色线条连接，并随着时间的推移逐渐消失。'\n  );\n}\n\nfunction draw() {\n  background(0);\n\n  // 更新并绘制所有路径\n  for (let path of paths) {\n    path.update();\n    path.display();\n  }\n}\n\n// 按下鼠标时创建一个新路径\nfunction mousePressed() {\n  nextParticleFrame = frameCount;\n  paths.push(new Path());\n\n  // 将上一颗粒子的位置重置为鼠标位置\n  // 这样路径中的第一颗粒子就没有速度\n  previousParticlePosition.set(mouseX, mouseY);\n  createParticle();\n}\n\n// 当鼠标拖动时添加粒子\nfunction mouseDragged() {\n  // 如果是添加新粒子的时候\n  if (frameCount >= nextParticleFrame) {\n    createParticle();\n  }\n}\n\nfunction createParticle() {\n  // 获取鼠标位置\n  let mousePosition = createVector(mouseX, mouseY);\n\n  // 新粒子的速度基于鼠标移动\n  let velocity = p5.Vector.sub(mousePosition, previousParticlePosition);\n  velocity.mult(0.05);\n\n  // 添加新的粒子\n  let lastPath = paths[paths.length - 1];\n  lastPath.addParticle(mousePosition, velocity);\n\n  // 安排下一颗粒子的生成时间\n  nextParticleFrame = frameCount + framesBetweenParticles;\n\n  // 存储鼠标值\n  previousParticlePosition.set(mouseX, mouseY);\n}\n\n// 路径是一个包含粒子的列表\nclass Path {\n  constructor() {\n    this.particles = [];\n  }\n\n  addParticle(position, velocity) {\n    // 添加一个新的粒子，包含位置、速度和色相\n    let particleHue = (this.particles.length * 30) % 360;\n    this.particles.push(new Particle(position, velocity, particleHue));\n  }\n\n  // 更新所有粒子\n  update() {\n    for (let particle of this.particles) {\n      particle.update();\n    }\n  }\n\n  // 在两个粒子之间绘制一条线\n  connectParticles(particleA, particleB) {\n    let opacity = particleA.framesRemaining / particleFadeFrames;\n    stroke(255, opacity);\n    line(\n      particleA.position.x,\n      particleA.position.y,\n      particleB.position.x,\n      particleB.position.y\n    );\n  }\n\n  // 显示路径\n  display() {\n    // 从后往前遍历，这样当粒子被移除时，\n    // 下一次循环的索引号会与移除粒子之前的粒子对齐\n    for (let i = this.particles.length - 1; i >= 0; i -= 1) {\n      // 如果粒子没有剩余帧数，移除它\n      if (this.particles[i].framesRemaining <= 0) {\n        this.particles.splice(i, 1);\n      } else {\n        this.particles[i].display();\n\n        // 如果此粒子后面还有其他粒子\n        if (i < this.particles.length - 1) {\n          // 用一条线将它们连接起来\n          this.connectParticles(this.particles[i], this.particles[i + 1]);\n        }\n      }\n    }\n  }\n}\n\n// 粒子类，表示路径上的一个粒子\nclass Particle {\n  constructor(position, velocity, hue) {\n    this.position = position.copy();\n    this.velocity = velocity.copy();\n    this.hue = hue;\n    this.drag = 0.95;\n    this.framesRemaining = particleFadeFrames;\n  }\n\n  update() {\n    // 移动粒子\n    this.position.add(this.velocity);\n\n    // 减慢粒子的速度\n    this.velocity.mult(this.drag);\n\n    // 使粒子逐渐消失\n    this.framesRemaining = this.framesRemaining - 1;\n  }\n\n  // 绘制粒子\n  display() {\n    let opacity = this.framesRemaining / particleFadeFrames;\n    noStroke();\n    fill(this.hue, 80, 90, opacity);\n    circle(this.position.x, this.position.y, 24);\n  }\n}"
},

  {
    "id": "p5_adv_020",
    "tag": "鸟类集群移动",
    "image": "/image/20.png",
    "code": "// Flock 类管理所有鸟类对象的数组\nlet flock;\n\nfunction setup() {\n  createCanvas(640, 360);\n  createP('拖动鼠标生成新的鸟类。');\n\n  flock = new Flock();\n\n  // 向系统中添加初始的鸟类集合\n  for (let i = 0; i < 100; i++) {\n    let b = new Boid(width / 2, height / 2);\n    flock.addBoid(b);\n  }\n\n  describe(\n    '一群类似鸟的物体，呈三角形状，在画布上移动，模拟群体行为。'\n  );\n}\n\nfunction draw() {\n  background(0);\n  flock.run();\n}\n\n// 鼠标拖动时，向鸟群中添加新的鸟类\nfunction mouseDragged() {\n  flock.addBoid(new Boid(mouseX, mouseY));\n}\n\n// Flock 类，用于管理所有鸟类的数组\nclass Flock {\n  constructor() {\n    // 初始化鸟类数组\n    this.boids = [];\n  }\n\n  run() {\n    for (let boid of this.boids) {\n      // 将整个鸟类列表传递给每只鸟\n      boid.run(this.boids);\n    }\n  }\n\n  addBoid(b) {\n    this.boids.push(b);\n  }\n}\n\nclass Boid {\n  constructor(x, y) {\n    this.acceleration = createVector(0, 0);\n    this.velocity = createVector(random(-1, 1), random(-1, 1));\n    this.position = createVector(x, y);\n    this.size = 3.0;\n\n    // 最大速度\n    this.maxSpeed = 3;\n\n    // 最大转向力\n    this.maxForce = 0.05;\n    colorMode(HSB);\n    this.color = color(random(256), 255, 255);\n  }\n\n  run(boids) {\n    this.flock(boids);\n    this.update();\n    this.borders();\n    this.render();\n  }\n\n  applyForce(force) {\n    // 我们可以在这里添加质量：A = F / M\n    this.acceleration.add(force);\n  }\n\n  // 每次根据三个规则积累新的加速度\n  flock(boids) {\n    let separation = this.separate(boids);\n    let alignment = this.align(boids);\n    let cohesion = this.cohesion(boids);\n\n    // 随意加权这些力\n    separation.mult(1.5);\n    alignment.mult(1.0);\n    cohesion.mult(1.0);\n\n    // 将这些力向量添加到加速度中\n    this.applyForce(separation);\n    this.applyForce(alignment);\n    this.applyForce(cohesion);\n  }\n\n  // 更新位置的方法\n  update() {\n    // 更新速度\n    this.velocity.add(this.acceleration);\n\n    // 限制速度\n    this.velocity.limit(this.maxSpeed);\n    this.position.add(this.velocity);\n\n    // 每次循环后重置加速度为 0\n    this.acceleration.mult(0);\n  }\n\n  // 计算并应用指向目标的转向力\n  // 转向 = 期望 - 速度\n  seek(target) {\n    // 一个指向目标位置的向量\n    let desired = p5.Vector.sub(target, this.position);\n\n    // 归一化期望并缩放至最大速度\n    desired.normalize();\n    desired.mult(this.maxSpeed);\n\n    // 转向 = 期望 - 速度\n    let steer = p5.Vector.sub(desired, this.velocity);\n\n    // 限制最大转向力\n    steer.limit(this.maxForce);\n    return steer;\n  }\n\n  render() {\n    // 绘制旋转的三角形，方向与速度一致\n    let theta = this.velocity.heading() + radians(90);\n    fill(this.color);\n    stroke(255);\n    push();\n    translate(this.position.x, this.position.y);\n    rotate(theta);\n    beginShape();\n    vertex(0, -this.size * 2);\n    vertex(-this.size, this.size * 2);\n    vertex(this.size, this.size * 2);\n    endShape(CLOSE);\n    pop();\n  }\n\n  // 边界处理\n  borders() {\n    if (this.position.x < -this.size) {\n      this.position.x = width + this.size;\n    }\n\n    if (this.position.y < -this.size) {\n      this.position.y = height + this.size;\n    }\n\n    if (this.position.x > width + this.size) {\n      this.position.x = -this.size;\n    }\n\n    if (this.position.y > height + this.size) {\n      this.position.y = -this.size;\n    }\n  }\n\n  // 分离\n  // 该方法检查附近的鸟类并避免它们过于接近\n  separate(boids) {\n    let desiredSeparation = 25.0;\n    let steer = createVector(0, 0);\n    let count = 0;\n\n    // 对每一只鸟类，检查它是否太近\n    for (let boid of boids) {\n      let distanceToNeighbor = p5.Vector.dist(this.position, boid.position);\n\n      // 如果距离大于 0 且小于一个任意的数值（自己除外）\n      if (distanceToNeighbor > 0 && distanceToNeighbor < desiredSeparation) {\n        // 计算指向远离邻居的向量\n        let diff = p5.Vector.sub(this.position, boid.position);\n        diff.normalize();\n\n        // 按距离缩放\n        diff.div(distanceToNeighbor);\n        steer.add(diff);\n\n        // 记录有多少个鸟类\n        count++;\n      }\n    }\n\n    // 平均 -- 除以数量\n    if (count > 0) {\n      steer.div(count);\n    }\n\n    // 如果向量大于 0\n    if (steer.mag() > 0) {\n      // 实现雷诺兹的公式：转向 = 期望 - 速度\n      steer.normalize();\n      steer.mult(this.maxSpeed);\n      steer.sub(this.velocity);\n      steer.limit(this.maxForce);\n    }\n    return steer;\n  }\n\n  // 对齐\n  // 对每只附近的鸟类，计算平均速度\n  align(boids) {\n    let neighborDistance = 50;\n    let sum = createVector(0, 0);\n    let count = 0;\n    for (let i = 0; i < boids.length; i++) {\n      let d = p5.Vector.dist(this.position, boids[i].position);\n      if (d > 0 && d < neighborDistance) {\n        sum.add(boids[i].velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      sum.div(count);\n      sum.normalize();\n      sum.mult(this.maxSpeed);\n      let steer = p5.Vector.sub(sum, this.velocity);\n      steer.limit(this.maxForce);\n      return steer;\n    } else {\n      return createVector(0, 0);\n    }\n  }\n\n  // 聚合\n  // 对所有附近鸟类的平均位置（即中心）计算指向该位置的转向向量\n  cohesion(boids) {\n    let neighborDistance = 50;\n    let sum = createVector(0, 0); // 从空向量开始累积所有位置\n    let count = 0;\n    for (let i = 0; i < boids.length; i++) {\n      let d = p5.Vector.dist(this.position, boids[i].position);\n      if (d > 0 && d < neighborDistance) {\n        sum.add(boids[i].position); // 添加位置\n        count++;\n      }\n    }\n    if (count > 0) {\n      sum.div(count);\n      return this.seek(sum); // 指向该位置\n    } else {\n      return createVector(0, 0);\n    }\n  }\n} // class Boid"
},
  {
    "id": "p5_adv_021",
    "tag": "烟雾例子",
    "image": "/image/21.png",
    "code": "// 声明粒子系统和纹理的变量\nlet particleTexture;\nlet particleSystem;\n\nfunction preload() {\n  particleTexture = loadImage('/assets/particle_texture.png');\n}\n\nfunction setup() {\n  // 设置画布大小\n  createCanvas(720, 400);\n  colorMode(HSB);\n\n  // 初始化粒子系统\n  particleSystem = new ParticleSystem(\n    0,\n    createVector(width / 2, height - 60),\n    particleTexture\n  );\n\n  describe(\n    '白色圆形物体在画布中央发出烟雾，风力由光标位置决定。'\n  );\n}\n\nfunction draw() {\n  background(20);\n\n  // 根据鼠标的 x 坐标计算风力\n  let dx = map(mouseX, 0, width, -0.2, 0.2);\n  let wind = createVector(dx, 0);\n\n  // 应用风力并运行粒子系统\n  particleSystem.applyForce(wind);\n  particleSystem.run();\n  for (let i = 0; i < 2; i += 1) {\n    particleSystem.addParticle();\n  }\n\n  // 绘制代表风力的箭头\n  drawVector(wind, createVector(width / 2, 50, 0), 500);\n}\n\n// 显示箭头以显示向量的大小和方向\nfunction drawVector(v, loc, scale) {\n  push();\n  let arrowSize = 4;\n  translate(loc.x, loc.y);\n  stroke(255);\n  strokeWeight(3);\n  rotate(v.heading());\n\n  let length = v.mag() * scale;\n  line(0, 0, length, 0);\n  line(length, 0, length - arrowSize, +arrowSize / 2);\n  line(length, 0, length - arrowSize, -arrowSize / 2);\n  pop();\n}\n\nclass ParticleSystem {\n  constructor(particleCount, origin, textureImage) {\n    this.particles = [];\n\n    // 复制输入的向量\n    this.origin = origin.copy();\n    this.img = textureImage;\n    for (let i = 0; i < particleCount; ++i) {\n      this.particles.push(new Particle(this.origin, this.img));\n    }\n  }\n\n  run() {\n    // 遍历并运行每个粒子\n    for (let i = this.particles.length - 1; i >= 0; i -= 1) {\n      let particle = this.particles[i];\n      particle.run();\n\n      // 移除已死亡的粒子\n      if (particle.isDead()) {\n        this.particles.splice(i, 1);\n      }\n    }\n  }\n\n  // 对每个粒子应用力\n  applyForce(dir) {\n    for (let particle of this.particles) {\n      particle.applyForce(dir);\n    }\n  }\n\n  addParticle() {\n    this.particles.push(new Particle(this.origin, this.img));\n  }\n} // class ParticleSystem\n\nclass Particle {\n  constructor(pos, imageTexture) {\n    this.loc = pos.copy();\n\n    let xSpeed = randomGaussian() * 0.3;\n    let ySpeed = randomGaussian() * 0.3 - 1.0;\n\n    this.velocity = createVector(xSpeed, ySpeed);\n    this.acceleration = createVector();\n    this.lifespan = 100.0;\n    this.texture = imageTexture;\n    this.color = color(frameCount % 256, 255, 255);\n  }\n\n  // 更新并绘制粒子\n  run() {\n    this.update();\n    this.render();\n  }\n\n  // 绘制粒子\n  render() {\n    imageMode(CENTER);\n    tint(this.color, this.lifespan);\n    image(this.texture, this.loc.x, this.loc.y);\n  }\n\n  applyForce(f) {\n    // 将力向量添加到当前的加速度向量中\n    this.acceleration.add(f);\n  }\n\n  isDead() {\n    return this.lifespan <= 0.0;\n  }\n\n  // 更新粒子的位置、速度和生命周期\n  update() {\n    this.velocity.add(this.acceleration);\n    this.loc.add(this.velocity);\n    this.lifespan -= 2.5;\n\n    // 将加速度重置为 0\n    this.acceleration.mult(0);\n  }\n} // class Particle"
},
  {
    "id": "p5_adv_022",
    "tag": "软体",
    "image": "/image/22.png",
     "code": "// 声明物理计算的变量\nlet centerX = 0.0;\nlet centerY = 0.0;\nlet radius = 45;\nlet rotAngle = -90;\nlet accelX = 0.0;\nlet accelY = 0.0;\nlet deltaX = 0.0;\nlet deltaY = 0.0;\nlet springing = 0.0009;\nlet damping = 0.98;\n\n// 声明指定顶点位置的变量\nlet nodes = 5;\nlet nodeStartX = [];\nlet nodeStartY = [];\nlet nodeX = [];\nlet nodeY = [];\nlet angle = [];\nlet frequency = [];\n\n// 声明曲线紧密度的变量\nlet organicConstant = 1.0;\n\nfunction setup() {\n  createCanvas(710, 400);\n\n  // 从画布中心开始\n  centerX = width / 2;\n  centerY = height / 2;\n\n  // 初始化数组为0\n  for (let i = 0; i < nodes; i++) {\n    nodeStartX[i] = 0;\n    nodeStartY[i] = 0;\n    nodeX[i] = 0;\n    nodeY[i] = 0;\n    angle[i] = 0;\n  }\n\n  // 初始化角落节点的频率\n  for (let i = 0; i < nodes; i++) {\n    frequency[i] = random(5, 12);\n  }\n\n  noStroke();\n  angleMode(DEGREES);\n}\n\nfunction draw() {\n  // 使用 alpha 混合实现渐变效果\n  background(0, 50);\n\n  // 绘制并移动形状\n  drawShape();\n  moveShape();\n}\n\nfunction drawShape() {\n  // 计算节点的起始位置\n  for (let i = 0; i < nodes; i++) {\n    nodeStartX[i] = centerX + cos(rotAngle) * radius;\n    nodeStartY[i] = centerY + sin(rotAngle) * radius;\n    rotAngle += 360.0 / nodes;\n  }\n\n  // 绘制多边形\n\n  curveTightness(organicConstant);\n  let shapeColor = lerpColor(color('red'), color('yellow'), organicConstant);\n  fill(shapeColor);\n\n  beginShape();\n  for (let i = 0; i < nodes; i++) {\n    curveVertex(nodeX[i], nodeY[i]);\n  }\n  endShape(CLOSE);\n}\n\nfunction moveShape() {\n  // 移动中心点\n  deltaX = mouseX - centerX;\n  deltaY = mouseY - centerY;\n\n  // 创建弹簧效果\n  deltaX *= springing;\n  deltaY *= springing;\n  accelX += deltaX;\n  accelY += deltaY;\n\n  // 移动中心\n  centerX += accelX;\n  centerY += accelY;\n\n  // 减慢弹簧效果\n  accelX *= damping;\n  accelY *= damping;\n\n  // 根据整体加速度变化曲线紧密度；\n  // 使用 abs() 来避免依赖于加速度方向\n  organicConstant = 1 - (abs(accelX) + abs(accelY)) * 0.1;\n\n  // 移动节点\n  for (let i = 0; i < nodes; i++) {\n    nodeX[i] = nodeStartX[i] + sin(angle[i]) * (accelX * 2);\n    nodeY[i] = nodeStartY[i] + sin(angle[i]) * (accelY * 2);\n    angle[i] += frequency[i];\n  }\n}"
},
  {
    "id": "p5_adv_023",
    "tag": "分形动画",
    "image": "/image/23.png",
    "code": "function setup() {\n  createCanvas(710, 400);\n  pixelDensity(1);\n  describe('多彩渲染曼德尔布罗集。');\n  background(0);\n\n  // 在复平面上建立一个值的范围\n  // 不同的宽度值改变缩放级别\n  let w = 4;\n  let h = (w * height) / width;\n\n  // 从负的半宽度和半高度开始\n  let xMin = -w / 2;\n  let yMin = -h / 2;\n\n  // 访问 pixels[] 数组\n  loadPixels();\n\n  // 设置每个点的最大迭代次数\n  let maxIterations = 100;\n\n  // x 从 xMin 到 xMax\n  let xMax = xMin + w;\n\n  // y 从 yMin 到 yMax\n  let yMax = yMin + h;\n\n  // 计算每个像素的 x, y 增量\n  let dx = (xMax - xMin) / width;\n  let dy = (yMax - yMin) / height;\n\n  // 从 y 开始\n  let y = yMin;\n  for (let j = 0; j < height; j += 1) {\n    // 从 x 开始\n    let x = xMin;\n    for (let i = 0; i < width; i += 1) {\n      // 测试 z = z^2 + cm 的迭代是否发散\n      let a = x;\n      let b = y;\n      let iterations = 0;\n      while (iterations < maxIterations) {\n        let aSquared = pow(a, 2);\n        let bSquared = pow(b, 2);\n        let twoAB = 2.0 * a * b;\n        a = aSquared - bSquared + x;\n        b = twoAB + y;\n\n        // 如果值太大，则停止迭代\n        if (dist(aSquared, bSquared, 0, 0) > 16) {\n          break;\n        }\n        iterations += 1;\n      }\n\n      // 根据到达无穷大的时间为每个像素着色\n\n      let index = (i + j * width) * 4;\n\n      // 将迭代次数映射到 0-1 范围\n      let normalized = map(iterations, 0, maxIterations, 0, 1);\n\n      // 使用归一化值的平方根进行颜色插值\n      let lerpAmount = sqrt(normalized);\n\n      // 设置默认颜色为黑色\n      let pixelColor = color(0);\n\n      // 蓝色\n      let startColor = color(47, 68, 159);\n\n      // 浅黄色\n      let endColor = color(255, 255, 128);\n\n      // 如果迭代次数小于最大值，插值颜色\n      if (iterations < maxIterations) {\n        pixelColor = lerpColor(startColor, endColor, lerpAmount);\n      }\n\n      // 将颜色的 RGBA 值复制到像素中\n      for (let i = 0; i < 4; i += 1) {\n        pixels[index + i] = pixelColor.levels[i];\n      }\n\n      x += dx;\n    }\n    y += dy;\n  }\n  updatePixels();\n}"
}
]
